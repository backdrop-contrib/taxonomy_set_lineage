<?php


/**
 * @file
 * Taxonomy set Lineage makes sure that for given vocabularies, parent terms are also selected
 */

/**
 * Implements hook_menu().
 */
function taxonomy_set_lineage_menu() {
  $items['admin/structure/taxonomy/taxonomy_set_lineage'] = array(
    'title' => 'Taxonomy Set Lineage',
    'description' => 'Configuration for the Taxonomy Set Lineage module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_set_lineage_config_form'),
    'access arguments' => array('administer taxonomy'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );
  return $items;
}

/**
 * Our configuration form.
 * 
 * @param $form
 *   The configuration form
 * @param $form_state
 *   The configuration form state
 */
function taxonomy_set_lineage_config_form($form, &$form_state) {
  $form['taxonomy_set_lineage_affected_taxonomies'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Set lineage in the following vocabularies:'),
    '#options' => array(),
    '#description' => t('Checked vocabularies will have parent terms of all selected terms automatically checked.  For instance, in a hypothetical vocabulary "Geography", if "Berlin" is checked, parent terms "Germany" and "Europe" would be automatically checked.  This behavior is true for any field referencing this vocabulary. Note that this does not change rules about the total number of terms that can be selected in a given field or field instance.'),
    '#default_value' => variable_get('taxonomy_set_lineage_affected_taxonomies', 0),
  );

  foreach (taxonomy_vocabulary_get_names() as $vocab) {
    $form['taxonomy_set_lineage_affected_taxonomies']['#options'][$vocab->machine_name] = check_plain($vocab->name);
  }
  return system_settings_form($form);  // thanks drupal!
}

/**
 * Implements hook_entity_presave().
 * 
 * Sets parent terms when entity is saved
 */
function taxonomy_set_lineage_entity_presave($entity, $type) {

  $wanted_vocabs = variable_get('taxonomy_set_lineage_affected_taxonomies', NULL);
  if (isset($wanted_vocabs)) {
    foreach ($wanted_vocabs as $wanted_vocab) {
      if ($wanted_vocab !== 0) {
        $field_name = _taxonomy_set_lineage_vocab_to_instance_field_name($entity, $type, $wanted_vocab);
        if (!empty($field_name)) {
          _taxonomy_set_lineage_activate_parents($entity, $type, $field_name);
        }
      }
    }
  }
}

/**
 * Helper function to find out which with which field name a taxonomy is attached to an entity
 * 
 * @param $entity
 *    The entity being saved.
 * @param $entity_type
 *   The type of the entity being saved.
 * @param $taxonomy_machine_name
 *   The machine name of the taxonomy for which we want to set parentage
 * 
 * @return 
 *   The machine name of the field which we want to manipulate
 */
function _taxonomy_set_lineage_vocab_to_instance_field_name($entity, $entity_type, $taxonomy_machine_name) {
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
  foreach (field_info_instances($entity_type, $bundle) as $instance) {
    $field = field_info_field_by_id($instance['field_id']);
    if ($field['type'] === 'taxonomy_term_reference') {
      $found_vocab_machine_name = $field['settings']['allowed_values'][0]['vocabulary'];
      // If the vocab we are looking for is found in field, return field name.
      if ($found_vocab_machine_name === $taxonomy_machine_name) {
        return $field['field_name'];
      }
    }
  }
}

/**
 * Activates all parent terms of any changed terms.
 * 
 * For all languages that are set on this vocabulary we check to see if they 
 * are changed from original entity i.e. were they just edited?
 * If so, we pull down their terms and save lineage (all parent terms) on them. 
 * This follows the principle of least surprise, and prevents us from having 
 * to do heuristics about the translation context.
 * 
 * @param $entity
 *    The entity being saved.
 * @param $type
 *   The type of the entity being saved.
 * @param $tax_field_name
 *   The machine name of the field which we want to manipulate
 */
function _taxonomy_set_lineage_activate_parents($entity, $type, $tax_field_name) {

  // Is there something to do?
  if (isset($entity->{$tax_field_name}) && is_array($entity->{$tax_field_name})) {
    foreach ($entity->{$tax_field_name} as $lang_code => $language) {
      // Two loops to check for changes.
      $language_changed = FALSE;
      // First the new state.
      $tidsnew = array();
      foreach ($language as $term) {
        $tidsnew[] .= isset($term['tid']) ? $term['tid'] : NULL;
      }
      // Now the old version of the entity.
      $tidsold = array();
      if (isset($entity->original->{$tax_field_name}[$lang_code])) {
        foreach ($entity->original->{$tax_field_name}[$lang_code] as $term) {
          $tidsold[] .= isset($term['tid']) ? $term['tid'] : NULL;
        }
      }
      // Are there changes?
      asort($tidsnew);
      asort($tidsold);
      if (count(array_diff($tidsnew, $tidsold)) > 0) {
        // Then do it!
        foreach ($language as $term) {
          // Get full ancestry of term... carefull, it includes our term also.
          $parent_term_objects = taxonomy_get_parents_all($term['tid']);
          foreach ($parent_term_objects as $parent) {
            // Filter out ourselves.
            if ($term['tid'] !== $parent->tid) {  
              $entity->{$tax_field_name}[$lang_code][] = array('tid' => $parent->tid);
            }
          }
        }
      }
    }
  } 
}
